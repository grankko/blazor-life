@using BlazorLife.Client.ViewModels
@using BlazorLife.Client.Interop
@using System.Timers;
@inject GameViewModel ViewModel

<div class="container">
    <div class="row" style="margin-top: 20px;">
        <div class="col-8">
            <button class="btn btn-primary" onclick="@ViewModel.Start">Start</button>
            <button class="btn btn-primary" onclick="@ViewModel.Stop">Stop</button>
            <button class="btn btn-secondary" onclick="@ViewModel.Reset">Reset</button>
            <button class="btn btn-secondary" onclick="@ViewModel.StepOneGeneration">Step one generation</button>
        </div>
        <div class="col-4">
            <div>Current live cells: <span id="currentLiveCellsSpan">@ViewModel.NumberOfLiveCells</span></div>
            <div>Current generation: <span id="currentGenerationSpan">@ViewModel.CurrentGeneration</span></div>
        </div>
    </div>
    <div class="row">
        <div class="col-12">
            <div class="btn-group" role="group" aria-label="Tools">
                <button type="button" class="btn btn-secondary" onclick="@(e => ViewModel.SelectedTool = Tool.Cell)" disabled=@(ViewModel.SelectedTool == Tool.Cell)>Cell</button>
                <button type="button" class="btn btn-secondary" onclick="@(e => ViewModel.SelectedTool = Tool.Glider)" disabled=@(ViewModel.SelectedTool == Tool.Glider)>Glider</button>
            </div>
        </div>
    </div>
</div>

@functions {

    private bool _isFirstRender = true;

    /// <summary>
    /// Hack. Way to make ViewModel paint when canvas is first available
    /// </summary>
    protected override void OnAfterRender()
    {
        if (_isFirstRender)
            ViewModel.Init();

        _isFirstRender = false;
    }

    protected override void OnInit()
    {
        CanvasFunctions.CanvasClicked += OnCanvasClicked;
        ViewModel.StateChanged += OnStateChanged;
    }

    protected void OnCanvasClicked(object sender, CanvasClickedEventArgs e)
    {
        ViewModel.AddLife(e.X, e.Y);
        this.StateHasChanged();
    }

    protected void OnStateChanged(object sender, EventArgs e)
    {
        this.StateHasChanged();
    }

}